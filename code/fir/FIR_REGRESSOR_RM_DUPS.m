function [dup_mask_all] = FIR_REGRESSOR_RM_DUPS(X)
    % INPUTS:
    % X: FIR regressor generated by fir_design.m
    % nans indicate subjects with missing response data
    % those subjects are easy to exclude
    %
    % however, it is also possible that you have two isolated stimuli who overlap such
    % that, e.g., t=4 of stim 1 is the same time as t=1 of stim 2, and
    % neither occur twice so you have a rank deficient matrix with two
    % identical columns. In this case, mask out both of those columns
    % without excluding entire subject
    % 
    % OUTPUTS:
    % dup_mask_all: mask for columns of X that are 1 for duplicates
    % AFTER you exclude all of the non-modeled parts of X
        
    nanmask_y = ~isnan(sum(X,1)); % remove regressors for subjects without data for a particular response
    nanmask_x = sum(X(:,nanmask_y),2) >0; % remove subjects who have no regressors after exclusion
    dup_mask_all = false(1,size(X,2)); % save duplicate mask
    if rank(X(nanmask_x,nanmask_y)) < min(size(X(nanmask_x,nanmask_y))) % if X is rank deficient
        X_inf = X; X_inf(isnan(X_inf)) = inf; % replace nans with infinity
        [X_inf_u,ia] = unique(X_inf','rows'); % now unique will count nans as a type of observation
        X_inf_u = X_inf_u';
        X_dup_index = find(~ismember(1:size(X_inf,2),ia) & nanmask_y); % indexes of one pair
        X_inf_d = X_inf(:,X_dup_index);
        for dup_col = 1:size(X_inf_d,2)
            % inf==inf is true. replace nans for inf thenlook for
            % exact matches of each duplicated column in X
            X_inf_dup_col = X_inf_d(:,dup_col); % get duplicated columns 1 at a time
            test_mat = repmat(X_inf_dup_col,[1 size(X,2)]); % repmat duplicated column, compare every column of X to duplicated column
            X_dup_mask = all(X_inf == test_mat,1); % get exact matching columns
            nanmask_y(X_dup_mask) = false; % add these duplicated columns to nanmask for y                
            dup_mask_all(X_dup_mask) = true;
        end
        % check whether X is still rank deficient after removing columns in
        % X_dup_mask
        if rank(X(nanmask_x,nanmask_y)) == min(size(X(nanmask_x,nanmask_y)))
            disp('found duplicated columns of X which when removed will successfully correct rank deficiency')
        else
            disp('ERROR: X is still rank deficient')
            % NOTE about this:
            % rank deficiency occurs when one column is a linear combination of other columns
            % in this context duplicates are the easy case of linear dependence to deal with
            % linear dependence also occurs here when you have a column (e.g. time point 5 of correct threat with 2 responses)
            % whose indicator positions can be completely recreated by adding together any number of the other regressors
            % This most commonly occurs when you
            return
        end
    else
        disp('X is not rank deficient')
    end